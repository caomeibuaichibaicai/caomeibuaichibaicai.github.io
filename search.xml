<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[es6_proto新方法]]></title>
    <url>%2F2019%2F04%2F16%2Fes6-proto%2F</url>
    <content type="text"><![CDATA[1.Object.setPrototypeOf()作用与proto相同，用来设置一个对象的prototype对象，返回参数对象本身。用来设置对象的原型对象，使原型对象的属性可以从对象上读取出来，并返回第一个参数obj 用法： Object.setPrototypeOf(obj,proto), 其中obj是对象，proto是原型对象，将proto对象设为obj对象的原型。若第一个参数不是对象，那么会自动转化为对象，但是最后还是返回的第一个参数，不会改变数据类型。但在这个过程中obj不能为undefined或者null，因为它们不能转化为对象，所以此时会报错。 2.Object.getPrototypeOf()用来读取一个对象的原型对象，例子如下：1234567function Rectangle() &#123; // ...&#125;//创建一个构造函数const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype===rec._proto_ 同样会将obj转化为对象，机制同上。 最后，给一个完整克隆一个对象的方法，包括拷贝对象原型的属性，有以下 三种方法：1234567891011121314151617// 写法一const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj);// 写法三const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 写法二和写法三的通用性更强，推荐！写法一可能proto属性在非浏览器环境下，不一定会被部署~~~~]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>es6_proto</tag>
        <tag>原型新方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js浮点数]]></title>
    <url>%2F2019%2F03%2F26%2FblogOne%2F</url>
    <content type="text"><![CDATA[Js浮点数小计 浮点数出现的原因js在进行计算时，需要将数字先转化为二进制，然后进行加减乘除的计算，得到的结果仍然是二进制，最后再转化为十进制，从而得到结果，在这个过程中就产生了 ==浮点数==，在小数位产生了误差。 js的计算 精度准确 的最大值是2^53^-1最小值为其对应的负数-2^53^-1若大于这个值就会出现精度丢失的情况，在2^53^至2^54^的范围内，只能计算出==偶数==；在2^54^至2^55^的范围内，只能四个数选一个，即==四的倍数==，后面以此类推，精度越来越小 js能 表示的 最大整数是2^1024^-1从2^1024^往后，后面的数字都只能被表示为Infinity 解决js浮点数中的加减乘除运算误差问题 ==单纯展示数据方法:==123function strip(num, precision = 12) &#123; return +parseFloat(num.toPrecision(precision));&#125; 先使用toPrecision对数字进行浮点数的处理，这个函数对超过指定精度的部分，进行一个凑整处理。(精度部分从最左边第一个不为0的位数开始计算)，通过经验计算，这个精度一般会选择12位。（当然也可以更高）之后会返回一个String类型的数字字符串，使用parseFloat对字符串进行转化为数字。 ==浮点进行运算方法：==这个时候的思路是把小数转化为整数，然后在进行运算.乘*：1234567891011121314151617181920const Mul = (num1, num2) =&gt; &#123; let m = 0 const s1 = `$&#123;num1&#125;` const s2 = `$&#123;num2&#125;` try &#123; // m += s1.split('.')[1].length m += get(s1.split('.'), '[1].length', 0) &#125; catch (e) &#123; console.error(e) &#125; try &#123; // m += s2.split('.')[1].length m += get(s2.split('.'), '[1].length', 0) &#125; catch (e) &#123; console.error(e) &#125; return Number(s1.replace('.', '')) * Number(s2.replace('.', '')) / Math.pow(10, m)&#125; 除/:1234567891011121314151617181920// 两个浮点数相除const Div = (num1, num2) =&gt; &#123; let t1 let t2 try &#123; // t1 = `$&#123;num1&#125;`.split('.')[1].length t1 = get(`$&#123;num1&#125;`.split('.'), '[1].length', 0) &#125; catch (e) &#123; t1 = 0 &#125; try &#123; // t2 = `$&#123;num2&#125;`.toString().split('.')[1].length t2 = get(`$&#123;num2&#125;`.toString().split('.'), '[1].length', 0) &#125; catch (e) &#123; t2 = 0 &#125; const r1 = Number(`$&#123;num1&#125;`.replace('.', '')) const r2 = Number(`$&#123;num2&#125;`.toString().replace('.', '')) return (r1 / r2) * Math.pow(10, t2 - t1)&#125; 加+：1234567891011121314151617// 两个浮点数相加const Add = (num1, num2) =&gt; &#123; let r1 let r2 try &#123; r1 = `$&#123;num1&#125;`.split('.')[1].length &#125; catch (e) &#123; r1 = 0 &#125; try &#123; r2 = `$&#123;num2&#125;`.split('.')[1].length &#125; catch (e) &#123; r2 = 0 &#125; const m = Math.pow(10, Math.max(r1, r2)) return Math.round(num1 * m + num2 * m) / m&#125; 减-：123456789101112131415161718// 两个浮点数相减const Sub = (num1, num2) =&gt; &#123; let r1 let r2 try &#123; r1 = `$&#123;num1&#125;`.split('.')[1].length &#125; catch (e) &#123; r1 = 0 &#125; try &#123; r2 = `$&#123;num2&#125;`.split('.')[1].length &#125; catch (e) &#123; r2 = 0 &#125; const m = Math.pow(10, Math.max(r1, r2)) const n = (r1 &gt;= r2) ? r1 : r2 return toFixed((Math.round(num1 * m - num2 * m) / m), n)&#125; 如果觉得很麻烦的话，当然也有现成的插件来用啊~~~比如：number-precision，这个库的优点在于体积小，只有不到1K的大小。还有我们熟知的math.js,里面的方法较全，代码可维护性也较高。 今天对浮点数的小计差不多就到这里啦💗]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[firstArtical]]></title>
    <url>%2F2019%2F03%2F07%2FfirstArtical%2F</url>
    <content type="text"><![CDATA[这是我第二次来hexo的第一天呀~第二次见面了，hexo老朋友，17年的时候第一次使用基于node的静态资源博客 hexo 当时第一次接触感觉，这个框架好方便，网上教程很多，可以自定义许多炫酷的特效，页面响应速度也比较快，于是就开始陆续的把博客搬到这个平台，后面因为一些个人的原因，没什么时间写博客，后来换了电脑后，就彻底丢掉了之前的博客源代码，这次趁着项目时间不是紧，又开始重新上手，哈哈哈哈哈，这次代码还做了备份，很方便，妈妈再也不用担心我换电脑了，备份参考链接在这里：点我点我]]></content>
      <categories>
        <category>trytry</category>
      </categories>
      <tags>
        <tag>first标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[error处理语法]]></title>
    <url>%2F2017%2F04%2F11%2Ferr-catch%2F</url>
    <content type="text"><![CDATA[###1.try-catch语法解释用法try是定义用来测试代码块出现错误的语句，必须和catch或者finally连用，也可以三个都一起用。catch只有当发生错误时才会执行，finally无论有无异常都会执行。还有一个throw语句是用来创建自定义错误语句，抛出js语句停止运行时的错误，可通过此自定义错误信息，如在try语句里面去自定义throw抛出的语句，在catch里面可接受自定义的err错误对象。 ###2.用法举例123456try &#123; adddlert("欢迎光临！");&#125;catch(err) &#123; document.getElementById("demo").innerHTML = err.message;&#125;]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>错误处理语法</tag>
      </tags>
  </entry>
</search>
